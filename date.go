package gofastdate

import "math/bits"

type Date struct {
	year uint64
	// TODO: maybe pack these two in one uint8, since we only need 1-12 for
	// months and 1-31 for days, meaning we could assign the first four bits to
	// months and the latter four to days?
	month uint8
	day   uint8
}

func FromUnix(unix int64) Date {
	days := unix / 86400
	day, month, year := benjoffeFastDate(days)
	return Date{
		year,
		uint8(month),
		uint8(day),
	}
}

// ported from https://www.benjoffe.com/fast-date-64
func benjoffeFastDate(dayNumber int64) (uint64, uint64, uint64) {
	// ben joffes licence, since this is a port:

	// Boost Software License - Version 1.0 - August 17th, 2003
	//
	// Copyright (c) 2025 Ben Joffe - https://www.benjoffe.com/fast-date-64
	//
	// Permission is hereby granted, free of charge, to any person or organization
	// obtaining a copy of the software and accompanying documentation covered by
	// this license (the "Software") to use, reproduce, display, distribute,
	// execute, and transmit the Software, and to prepare derivative works of the
	// Software, and to permit third-parties to whom the Software is furnished to
	// do so, all subject to the following:
	//
	// The copyright notices in the Software and this entire statement, including
	// the above license grant, this restriction and the following disclaimer,
	// must be included in all copies of the Software, in whole or in part, and
	// all derivative works of the Software, unless such copies or derivative
	// works are solely in the form of machine-executable object code generated by
	// a source language processor.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
	// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
	// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
	// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	// DEALINGS IN THE SOFTWARE.

	// Adjust for 100/400 leap year rule.
	rev := d_shift - uint64(dayNumber) // Reverse day count

	// uint64_t cen = (uint128_t(C1) * rev) >> 64;
	hi, _ := bits.Mul64(rev, c1) // Divide 36524.25
	cen := hi
	jul := rev + cen - cen/4 // Julian map

	// Determine year and year-part.

	// uint128_t num = uint128_t(C2) * jul;
	hi, lo := bits.Mul64(jul, c2) // Divide 365.25
	// uint32_t yrs = Y_SHIFT - uint32_t(num >> 64);
	yrs := y_shift - hi // Forward year
	// uint64_t low = uint64_t(num);
	low := lo // Lower 64 bits
	// uint32_t ypt = uint32_t(uint128_t(24451 * SCALE) * low >> 64);
	ypt, _ := bits.Mul64(24451*scale, low) // Year-part (backwards)

	bump := ypt < (3952 * scale) // Jan or Feb
	// bump ? SHIFT_1 : SHIFT_0
	shift := shift_0 // Month offset
	if bump {
		shift = shift_1
	}

	// Year-modulo-bitshift for leap years.
	// Also revert to forward direction.
	N := (yrs%4)*(16*scale) + shift - ypt
	M := N / (2048 * scale)
	// uint32_t const D = uint32_t(uint128_t(C3) * (N % (2048 * SCALE)) >> 64);
	D, _ := bits.Mul64(c3, N%(2048*scale))
	D += 1

	if bump {
		yrs += 1
	}

	return D, M, yrs
}
