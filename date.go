package gofastdate

import "math/bits"

type Date struct {
	day   uint64
	month uint64
	year  uint64
}

func FromUnix(unix int64) Date {
	days := unix / 86400
	day, month, year := benjoffeFastDate(days)
	return Date{day, month, year}
}

// ported from https://www.benjoffe.com/fast-date-64
func benjoffeFastDate(dayNumber int64) (uint64, uint64, uint64) {
	// ben joffes licence, since this is a port:

	// Boost Software License - Version 1.0 - August 17th, 2003
	//
	// Copyright (c) 2025 Ben Joffe - https://www.benjoffe.com/fast-date-64
	//
	// Permission is hereby granted, free of charge, to any person or organization
	// obtaining a copy of the software and accompanying documentation covered by
	// this license (the "Software") to use, reproduce, display, distribute,
	// execute, and transmit the Software, and to prepare derivative works of the
	// Software, and to permit third-parties to whom the Software is furnished to
	// do so, all subject to the following:
	//
	// The copyright notices in the Software and this entire statement, including
	// the above license grant, this restriction and the following disclaimer,
	// must be included in all copies of the Software, in whole or in part, and
	// all derivative works of the Software, unless such copies or derivative
	// works are solely in the form of machine-executable object code generated by
	// a source language processor.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
	// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
	// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
	// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	// DEALINGS IN THE SOFTWARE.

	const (
		eRAS    uint64 = 4726498270 // Use 14704 for 32â€“bit
		dSHIFT  uint64 = 146097*eRAS - 719469
		ySHIFT  uint64 = 400*eRAS - 1
		c1      uint64 = 505054698555331   // floor(2^64*4/146097)
		c2      uint64 = 50504432782230121 // ceil(2^64*4/1461)
		c3      uint64 = 8619973866219416  // floor(2^64/2140)
		SCALE   uint64 = 32                // SCALE = 32 for non-ARM builds
		SHIFT_0 uint64 = 30556 * 32        // 30556 * SCALE = 977792
		SHIFT_1 uint64 = 5980 * 32         // 5980  * SCALE = 191360
	)

	// Adjust for 100/400 leap year rule.
	rev := dSHIFT - uint64(dayNumber) // Reverse day count

	// uint64_t cen = (uint128_t(C1) * rev) >> 64;
	hi, _ := bits.Mul64(rev, c1) // Divide 36524.25
	cen := hi
	jul := rev + cen - cen/4 // Julian map

	// Determine year and year-part.

	// uint128_t num = uint128_t(C2) * jul;
	hi, lo := bits.Mul64(jul, c2) // Divide 365.25
	// uint32_t yrs = Y_SHIFT - uint32_t(num >> 64);
	yrs := ySHIFT - hi // Forward year
	// uint64_t low = uint64_t(num);
	low := lo // Lower 64 bits
	// uint32_t ypt = uint32_t(uint128_t(24451 * SCALE) * low >> 64);
	ypt, _ := bits.Mul64(24451*SCALE, low) // Year-part (backwards)

	bump := ypt < (3952 * SCALE) // Jan or Feb
	// bump ? SHIFT_1 : SHIFT_0
	shift := SHIFT_0 // Month offset
	if bump {
		shift = SHIFT_1
	}

	// Year-modulo-bitshift for leap years.
	// Also revert to forward direction.
	N := (yrs%4)*(16*SCALE) + shift - ypt
	M := N / (2048 * SCALE)
	// uint32_t const D = uint32_t(uint128_t(C3) * (N % (2048 * SCALE)) >> 64);
	D, _ := bits.Mul64(c3, N%(2048*SCALE))
	D += 1

	if bump {
		yrs += 1
	}

	return D, M, yrs
}
